
# ADAS Alert Data Preprocessing
This notebook outlines the data preprocessing steps for the ADAS Alert Analysis project. We will explore the data, clean it, and prepare it for further analysis. Each section includes theoretical explanations, code snippets, and visual outputs.

## 1. Introduction to the Dataset
Before diving into the preprocessing steps, let's first understand the structure of the dataset. The data consists of approximately 6700 rows, each representing an alert generated by an Advanced Driver Assistance System (ADAS) across different vehicles.

### *Dataset Overview*
**Alert:** Type of ADAS alert generated.
**Date:** Date when the alert was triggered.
**Time:** Exact time the alert was generated.
**Lat:** Latitude of the vehicle's location.
**Long:** Longitude of the vehicle's location.
**Vehicle:** Identifier for the vehicle that generated the alert.
**Speed:** The speed of the vehicle at the time of alert generation.
## 2. Loading the Dataset
First, we load the dataset using pandas to begin our preprocessing.


    import pandas as pd

    # Load the dataset
    file_path = 'path_to_your_csv_file.csv'  # Update this with the actual path to your dataset
    data = pd.read_csv(file_path)

### Display the first few rows of the dataset
    data.head()

  ![image](https://github.com/user-attachments/assets/8c05d194-1fd9-419d-9513-2ad646064a84)


#### 3. Basic Dataset Information
Understanding the basic structure of the dataset is crucial. We will inspect the data types, check for missing values, and get a general overview.

### Basic Information about the dataset
    data.info()
    #Handling Missing Values
    #Missing data can skew the analysis. We will check for missing values and handle them appropriately.
![image](https://github.com/user-attachments/assets/3a3bb5e3-72ce-4ef9-9e3c-2f58320f6bc3)

### Check for any missing values in the dataset
    data.isnull().sum()
![image](https://github.com/user-attachments/assets/e841a1d4-222c-443a-9b98-883f20a0acc7)

## 4. Exploring Unique Vehicles and Alerts
Understanding the variety of vehicles and alerts present in the dataset helps in grasping the breadth of the data.

Identifying Unique Vehicles

### Get the list of unique vehicles in the dataset
    unique_vehicles = data['Vehicle'].unique()
    print(f"Number of unique vehicles: {len(unique_vehicles)}")
    #Identifying Unique Alerts

### Get the list of unique alerts in the dataset
    unique_alerts = data['Alert'].unique()
    print(f"Number of unique alert types: {len(unique_alerts)}")
![image](https://github.com/user-attachments/assets/d1b44be5-0741-488f-8563-f11432cf8413)

## 5. Date and Time Conversion
For better analysis, the Date and Time columns need to be in the appropriate format. We will convert them to datetime and extract useful components like year, month, and day.

### Convert the 'Date' and 'Time' columns to datetime format
    data['Date'] = pd.to_datetime(data['Date'])
    data['Time'] = pd.to_datetime(data['Time'], format='%H:%M:%S').dt.time

### Extract year, month, and day
    data['Year'] = data['Date'].dt.year
    data['Month'] = data['Date'].dt.month
    data['Day'] = data['Date'].dt.day
## 6. Removing Duplicate Rows
Duplicate entries can distort analysis results. Weâ€™ll check for duplicates and remove them.

### Checking for and removing duplicate rows
    duplicates = data.duplicated()
    print(f"Number of duplicate rows: {duplicates.sum()}")
    data = data.drop_duplicates()
![image](https://github.com/user-attachments/assets/9a383e9a-ebfe-451a-9acf-863a5d37745f)

## 7. Saving the Cleaned Data
Finally, we save the cleaned dataset to a new CSV file for further analysis.



### Save the cleaned data
    cleaned_file_path = 'cleaned_data.csv'  # Update this with the desired path for the cleaned data
    data.to_csv(cleaned_file_path, index=False)

    print("Cleaned data saved to:", cleaned_file_path)




# ADAS Alert Data Exploratory Data Analysis (EDA)

This section of the project involves performing Exploratory Data Analysis (EDA) to understand the distribution and patterns within the ADAS Alert dataset.

## 1. Distribution of Alerts

We start by analyzing the distribution of different types of ADAS alerts in the dataset.
    
    plt.figure(figsize=(10, 6))
    sns.countplot(data['Alert'])
    plt.title('Distribution of ADAS Alerts')
    plt.xlabel('Alert Type')
    plt.ylabel('Count')
    plt.xticks(rotation=45)
    plt.show()
    
**Explanation:** The countplot visualizes the number of occurrences for each alert type. This helps us identify the most and least common alerts in the dataset.

## 2. Speed Distribution
Next, we explore how vehicle speed varies when alerts are triggered.

    plt.figure(figsize=(10, 6))
    sns.histplot(data['Speed'], bins=30, kde=True)
    plt.title('Speed Distribution at the Time of Alert')
    plt.xlabel('Speed (km/h)')
    plt.ylabel('Frequency')
    plt.show()
**Explanation:** A histogram with a Kernel Density Estimate (KDE) shows the distribution of vehicle speeds at the time of alert generation, highlighting common speed ranges associated with alerts.

## 3. Alerts by Vehicle
We then look at how alerts are distributed across different vehicles.

    plt.figure(figsize=(12, 6))
    sns.countplot(y='Vehicle', hue='Alert', data=data)
    plt.title('Number of Alerts per Vehicle')
    plt.xlabel('Count')
    plt.ylabel('Vehicle')
    plt.show()
**Explanation:** This plot shows the number of alerts each vehicle has generated, broken down by alert type. It helps in identifying if certain vehicles are more prone to specific alerts.

## 4. Alert Frequency by Time of Day
We also analyze when alerts are most frequently triggered during the day.

    data['Hour'] = pd.to_datetime(data['Time'], format='%H:%M:%S').dt.hour
    plt.figure(figsize=(10, 6))
    sns.countplot(data['Hour'], palette='viridis')
    plt.title('Alert Frequency by Hour of the Day')
    plt.xlabel('Hour of the Day')
    plt.ylabel('Number of Alerts')
    plt.show()
**Explanation:** By converting the time data to hours, we can observe which times of the day are most associated with alerts, giving insights into potential high-risk periods.

## 5. Correlation Heatmap
A correlation heatmap is generated to observe the relationships between different numerical features.

    plt.figure(figsize=(8, 6))
    sns.heatmap(data.corr(), annot=True, cmap='coolwarm')
    plt.title('Correlation Heatmap of Dataset Features')
    plt.show()
**Explanation:** The correlation heatmap highlights relationships between variables, such as speed and alert frequency, to uncover potential dependencies or patterns in the data.

## 6. Geographical Distribution of Alerts
Finally, we map the geographical distribution of alerts using latitude and longitude.

    plt.figure(figsize=(10, 6))
    sns.scatterplot(x='Long', y='Lat', hue='Alert', data=data)
    plt.title('Geographical Distribution of Alerts')
    plt.xlabel('Longitude')
    plt.ylabel('Latitude')
    plt.show()
**Explanation:** This scatter plot shows where alerts occur on a map, revealing geographic hotspots where certain alerts are more frequent.


# ADAS Alert Data Visualization

This section presents visualizations that highlight key insights from the ADAS Alert dataset. Each visualization is accompanied by an explanation to help interpret the results.

## 1. Bar Plot of Alerts by Vehicle

We begin with a bar plot that shows the distribution of alerts across different vehicles.

    plt.figure(figsize=(12, 6))
    sns.countplot(x='Vehicle', hue='Alert', data=data)
    plt.title('Bar Plot of Alerts by Vehicle')
    plt.xlabel('Vehicle')
    plt.ylabel('Number of Alerts')
    plt.xticks(rotation=45)
    plt.show()

**Explanation:** This bar plot helps identify which vehicles are most associated with specific types of alerts. It's useful for understanding vehicle behavior and alert patterns.

## 2. Speed vs. Alerts Boxplot
Next, we examine how vehicle speed varies across different alert types using a boxplot.

    plt.figure(figsize=(10, 6))
    sns.boxplot(x='Alert', y='Speed', data=data)
    plt.title('Speed Distribution across Different Alerts')
    plt.xlabel('Alert Type')
    plt.ylabel('Speed (km/h)')
    plt.xticks(rotation=45)
    plt.show()
**Explanation:** The boxplot illustrates the speed distribution for each alert type, revealing how speed influences alert generation and highlighting potential outliers.

## 3. Pair Plot of Numerical Features
We then create a pair plot to visualize relationships between numerical features like speed, latitude, and longitude.

    sns.pairplot(data[['Speed', 'Lat', 'Long']])
    plt.suptitle('Pair Plot of Speed, Latitude, and Longitude', y=1.02)
    plt.show()
**Explanation:** The pair plot shows scatter plots of numerical feature pairs, helping to identify correlations or patterns between variables such as speed and location data.

## 4. Time Series Plot of Alerts Over Days
A time series plot is used to observe how the number of alerts changes over time.

    data['Date'] = pd.to_datetime(data['Date'])
    alerts_per_day = data.groupby('Date').size()
    plt.figure(figsize=(12, 6))
    alerts_per_day.plot()
    plt.title('Time Series Plot of Alerts Over Time')
    plt.xlabel('Date')
    plt.ylabel('Number of Alerts')
    plt.show()
**Explanation:** This plot tracks the number of alerts generated each day, helping to identify trends or periodic spikes in alert frequency over time.

## 5. Heatmap of Alerts per Vehicle and Time of Day
Lastly, we visualize the concentration of alerts for each vehicle across different hours of the day using a heatmap.

    data['Hour'] = pd.to_datetime(data['Time'], format='%H:%M:%S').dt.hour
    heatmap_data = data.pivot_table(index='Vehicle', columns='Hour', aggfunc='size', fill_value=0)
    plt.figure(figsize=(14, 8))
    sns.heatmap(heatmap_data, cmap='coolwarm')
    plt.title('Heatmap of Alerts per Vehicle and Time of Day')
    plt.xlabel('Hour of the Day')
    plt.ylabel('Vehicle')
    plt.show()
**Explanation:** The heatmap highlights when and which vehicles are more prone to generating alerts throughout the day. It can help in scheduling maintenance or understanding driver behavior.
